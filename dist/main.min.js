!function e(t,n,i){function r(a,s){if(!n[a]){if(!t[a]){var l="function"==typeof require&&require;if(!s&&l)return l(a,!0);if(o)return o(a,!0);var u=new Error("Cannot find module '"+a+"'");throw u.code="MODULE_NOT_FOUND",u}var p=n[a]={exports:{}};t[a][0].call(p.exports,function(e){var n=t[a][1][e];return r(n?n:e)},p,p.exports,e,t,n,i)}return n[a].exports}for(var o="function"==typeof require&&require,a=0;a<i.length;a++)r(i[a]);return r}({1:[function(e,t,n){"use strict";function i(e,t){var n=new PIXI.Matrix;PIXI.Filter.call(this,r,o),this.padding=0,t.renderable=!1,this.maskedSprite=e,this.maskSprite=t,this.maskMatrix=n,this.setDimensions()}var r="#define GLSLIFY 1\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\n\nuniform mat3 otherMatrix;\nvarying vec2 vMaskCoord;\n  \n  void main(void)\n  {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n  }",o="// \n// --------\n// Uniforms\n// --------\n// \n// 1) (vec2) vidDimensions \n//   - dimensions of the FULL video texture \n//     (including top RGB panel and bottom Alpha panel)\n// \n// 2) (float) spriteAlpha\n//   - the current alpha of the alphaVideoSprite - need to\n//     multiply the computed alpha by this to get the actual\n//     alpha (NOTE: this is only important if video alpha is \n//     NOT `0` or `1`).\n// \n// 2) (float) yOffset \n//   - alpha offset from y midpoint (height / 2.0). useful if\n//      RGB panel and Alpha panel in are different heights\n//      and also for debugging.\n// \n// 3) (sampler2D) uSampler\n//   - Texture of the PIXI sprite (video) we are applying the filter to. \n//     This is passed in by PIXI.\n// \n// 4) (sampler2D) mask \n//   - Used to get alpha value. Basically the same as `uSampler`.\n//     the issue with JUST using `uSampler`, however, is that when\n//     the Alpha panel overflows the PIXI container (even if we can't\n//     see it), it won't render properly. Thus it seems we need to \n//     pass it in again, as a full, uncropped texture.\n// \n// \n// TODO\n// - Use STPQ (texture coord syntax) for accessing textures ??\n// \n// NOTES\n// - Final post in this thread might be useful:\n//   https://github.com/pixijs/pixi.js/issues/1977\n//  \n\nprecision lowp float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMaskCoord;\nvarying vec4 vColor;\n\nuniform vec2 vidDimensions;\nuniform float spriteAlpha;\nuniform float yOffset;\nuniform sampler2D uSampler;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n\n  vec2 onePixel = vec2(1.0 / vidDimensions);\n\n  float offsetHeight = yOffset + vidDimensions.y;\n\n  float filterHeight = offsetHeight * onePixel.y;\n  float halfHeight = filterHeight / 2.0;\n\n  float alphaPixelY = vTextureCoord.y + (halfHeight * onePixel.y);\n  vec2 alphaPixel = vec2(vTextureCoord.x, alphaPixelY);\n\n  vec4 colorPx = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\n  vec4 alphaPx = texture2D(mask, vec2(vMaskCoord.x, vMaskCoord.y + halfHeight));\n\n  float alpha = alphaPx.r * spriteAlpha;\n\n  // // check clip! this will stop the mask bleeding out from the edges\n  // // might not need this after all\n  // vec2 text = abs( vMaskCoord - 0.5 );\n  // text = step(0.5, text);\n  // float clip = 1.0 - max(text.y, text.x);\n\n  // alpha *= clip;\n\n  /**\n   * pixel alpha is based on Y position (top is `0`, bottom is `1`)\n   */\n  // float pctDown = vTextureCoord.y / filterHeight;\n  // color *= pctDown;\n  // gl_FragColor = vec4(colorPx.rgb, pctDown);\n\n  /**\n   * just the video in it's original state\n   */\n  // gl_FragColor = colorPx;\n  \n  /**\n   * just show the alpha half\n   */\n  // gl_FragColor = alphaPx;\n  \n  /**\n   * actual working version\n   */\n  gl_FragColor = vec4(colorPx.rgb * alpha, alpha);\n}";i.prototype=Object.create(PIXI.Filter.prototype),i.prototype.constructor=i,t.exports=i,i.prototype.apply=function(e,t,n){var i=this.maskSprite;this.uniforms.mask=i._texture;var r=e.calculateSpriteMatrix(this.maskMatrix,i);this.uniforms.otherMatrix=r,e.applyFilter(this,t,n)},i.prototype.setDimensions=function(){var e=this.uniforms.vidDimensions;e[0]=this.maskedSprite.width,e[1]=2*this.maskedSprite.height},Object.defineProperties(i.prototype,{spriteAlpha:{get:function(){return this.uniforms.spriteAlpha},set:function(e){this.uniforms.spriteAlpha=e}},yOffset:{get:function(){return this.uniforms.yOffset},set:function(e){this.uniforms.yOffset=e}}}),t.exports=i},{}],2:[function(e,t,n){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),s=function e(t,n,i,r){var o=Object.getOwnPropertyDescriptor(t,n);if(void 0===o){var a=Object.getPrototypeOf(t);null!==a&&e(a,n,i,r)}else if("value"in o&&o.writable)o.value=i;else{var s=o.set;void 0!==s&&s.call(r,i)}return i},l=function e(t,n,i){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var o=Object.getPrototypeOf(t);return null===o?void 0:e(o,n,i)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(i)},u=e("./VideoMaskFilter"),p=function(e){function t(e,n,o){i(this,t);var a=r(this,Object.getPrototypeOf(t).call(this));return a._fullTexture=e,a._srcEl=a._fullTexture.baseTexture.source,o=o||!1,a._fullTexture.baseTexture.autoUpdate=o,a._srcEl.loop=!0,a._alpha=1,a.setup(o),a.setFilter(n),a.shimScaleCallback(),a}return o(t,e),a(t,[{key:"setup",value:function(){var e=this.srcWidth,t=this.srcHeight/2;this.texture=new PIXI.Texture(this._fullTexture,new PIXI.Rectangle(0,0,e,t)),this.maskTexture=new PIXI.Texture(this._fullTexture,new PIXI.Rectangle(0,t,e,t)),this.maskSprite=new PIXI.Sprite(this.maskTexture),this.addChild(this.maskSprite)}},{key:"listen",value:function(){}},{key:"setFilter",value:function(e){var t=new u(this,this.maskSprite);return e&&(t.padding=e),this.filter=t,this.filters=[this.filter],this.alpha=this._alpha,t}},{key:"removeFilter",value:function(){var e=this.sprite.filter;return this.filters=null,this.filter=null,e}},{key:"update",value:function(){this._fullTexture.baseTexture.update()}},{key:"shimScaleCallback",value:function(){var e=this,t=this.scale.scope,n=this.scale.cb,i=function(){n.call(t),e.filter.setDimensions()};this.scale.cb=i}},{key:"width",get:function(){return l(Object.getPrototypeOf(t.prototype),"width",this)},set:function(e){s(Object.getPrototypeOf(t.prototype),"width",e,this)}},{key:"height",get:function(){return l(Object.getPrototypeOf(t.prototype),"height",this)},set:function(e){s(Object.getPrototypeOf(t.prototype),"height",e,this)}},{key:"alpha",get:function(){return this._alpha},set:function(e){this.filter&&(this.filter.spriteAlpha=e),this._alpha=e}},{key:"srcWidth",get:function(){return this._srcEl.videoWidth}},{key:"srcHeight",get:function(){return this._srcEl.videoHeight}}]),t}(PIXI.Sprite);t.exports=p},{"./VideoMaskFilter":1}],3:[function(e,t,n){(function(n){"use strict";var i=e("./AlphaVideoSprite");t.exports=n.PIXI.AlphaVideoSprite=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./AlphaVideoSprite":2}]},{},[3]);
//# sourceMappingURL=dist/main.min.js.map