(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){"use strict";var vShader="#define GLSLIFY 1\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\n\nuniform mat3 otherMatrix;\nvarying vec2 vMaskCoord;\n  \n  void main(void)\n  {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n  }";var fShader="// \n// --------\n// Uniforms\n// --------\n// \n// 1) (vec2) vidDimensions \n//   - dimensions of the FULL video texture \n//     (including top RGB panel and bottom Alpha panel)\n// \n// 2) (float) yOffset \n//   - alpha offset from y midpoint (height / 2.0). useful if\n//      RGB panel and Alpha panel in are different heights\n//      and also for debugging.\n// \n// 3) (sampler2D) uSampler\n//   - Texture of the PIXI sprite (video) we are applying the filter to. \n//     This is passed in by PIXI.\n// \n// 4) (sampler2D) mask \n//   - Used to get alpha value. Basically the same as `uSampler`.\n//     the issue with JUST using `uSampler`, however, is that when\n//     the Alpha panel overflows the PIXI container (even if we can't\n//     see it), it won't render properly. Thus it seems we need to \n//     pass it in again, as a full, uncropped texture.\n// \n// \n// TODO\n// - Use STPQ (texture coord syntax) for accessing textures ??\n// \n// NOTES\n// - Final post in this thread might be useful:\n//   https://github.com/pixijs/pixi.js/issues/1977\n//  \n\nprecision lowp float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMaskCoord;\nvarying vec4 vColor;\n\nuniform vec2 vidDimensions;\nuniform float yOffset;\nuniform sampler2D uSampler;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n\n  vec2 onePixel = vec2(1.0 / vidDimensions);\n\n  float offsetHeight = yOffset + vidDimensions.y;\n\n  float filterHeight = offsetHeight * onePixel.y;\n  float halfHeight = filterHeight / 2.0;\n\n  float alphaPixelY = vTextureCoord.y + (halfHeight * onePixel.y);\n  vec2 alphaPixel = vec2(vTextureCoord.x, alphaPixelY);\n\n  vec4 colorPx = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\n  vec4 alphaPx = texture2D(mask, vec2(vMaskCoord.x, vMaskCoord.y + halfHeight));\n\n  float alpha = alphaPx.r;\n\n  /**\n   * pixel alpha is based on Y position (top is `0`, bottom is `1`)\n   */\n  // float pctDown = vTextureCoord.y / filterHeight;\n  // color *= pctDown;\n  // gl_FragColor = vec4(colorPx.rgb, pctDown);\n\n  /**\n   * just the video in it's original state\n   */\n  // gl_FragColor = colorPx;\n  \n  /**\n   * just show the alpha half\n   */\n  // gl_FragColor = alphaPx;\n  \n  /**\n   * actual working version\n   */\n  gl_FragColor = vec4(colorPx.rgb * alpha, alpha);\n}";function VideoMaskFilter(maskedSprite,maskSprite){var maskMatrix=new PIXI.Matrix;PIXI.Filter.call(this,vShader,fShader);maskSprite.renderable=false;this.maskedSprite=maskedSprite;this.maskSprite=maskSprite;this.maskMatrix=maskMatrix;this.setDimensions()}VideoMaskFilter.prototype=Object.create(PIXI.Filter.prototype);VideoMaskFilter.prototype.constructor=VideoMaskFilter;module.exports=VideoMaskFilter;VideoMaskFilter.prototype.apply=function(filterManager,input,output){var maskSprite=this.maskSprite;this.uniforms.mask=maskSprite._texture;var otherMatrix=filterManager.calculateSpriteMatrix(this.maskMatrix,maskSprite);this.uniforms.otherMatrix=otherMatrix;filterManager.applyFilter(this,input,output)};VideoMaskFilter.prototype.setDimensions=function(){var vidDimensions=this.uniforms.vidDimensions;vidDimensions[0]=this.maskedSprite.width;vidDimensions[1]=this.maskedSprite.height*2};Object.defineProperties(VideoMaskFilter.prototype,{yOffset:{get:function get(){return this.uniforms.yOffset},set:function set(value){this.uniforms.yOffset=value}}});module.exports=VideoMaskFilter},{}],2:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}return call&&(typeof call==="object"||typeof call==="function")?call:self}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass)}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass}var VideoMaskFilter=require("./VideoMaskFilter");var Video=function(_PIXI$Sprite){_inherits(Video,_PIXI$Sprite);function Video(videoFullTexture){_classCallCheck(this,Video);var _this=_possibleConstructorReturn(this,Object.getPrototypeOf(Video).call(this));_this._fullTexture=videoFullTexture;_this._srcEl=_this._fullTexture.baseTexture.source;_this._srcEl.loop=true;_this.setup();_this.setFilter();_this.shimScaleCallback();return _this}_createClass(Video,[{key:"setup",value:function setup(){var newWidth=this.srcWidth;var newHeight=this.srcHeight/2;this.texture=new PIXI.Texture(this._fullTexture,new PIXI.Rectangle(0,0,newWidth,newHeight));this.maskTexture=new PIXI.Texture(this._fullTexture,new PIXI.Rectangle(0,newHeight,newWidth,newHeight));this.maskSprite=new PIXI.Sprite(this.maskTexture);this.addChild(this.maskSprite)}},{key:"listen",value:function listen(){}},{key:"setFilter",value:function setFilter(){var filter=new VideoMaskFilter(this,this.maskSprite);this.filter=filter;this.filters=[this.filter];return filter}},{key:"removeFilter",value:function removeFilter(){var filter=this.sprite.filter;this.filters=null;this.filter=null;return filter}},{key:"shimScaleCallback",value:function shimScaleCallback(){var spriteScope=this;var scaleScope=this.scale.scope;var oldCB=this.scale.cb;var newCB=function newCB(){oldCB.call(scaleScope);spriteScope.filter.setDimensions()};this.scale.cb=newCB}},{key:"srcWidth",get:function get(){return this._srcEl.videoWidth}},{key:"srcHeight",get:function get(){return this._srcEl.videoHeight}}]);return Video}(PIXI.Sprite);module.exports=Video},{"./VideoMaskFilter":1}],3:[function(require,module,exports){"use strict";var AlphaVideoSprite=require("./AlphaVideoSprite");module.exports=AlphaVideoSprite},{"./AlphaVideoSprite":2}]},{},[3]);
//# sourceMappingURL=dist/main.min.js.map